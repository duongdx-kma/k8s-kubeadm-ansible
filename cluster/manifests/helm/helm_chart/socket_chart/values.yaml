# Default values for socket_chart.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
# Additional image on the output Deployment definition.
image:
  registry: docker.io
  pullPolicy: IfNotPresent
  repositories:
    backend:
      name: golang backend websocket
      image: duong1200798/golang_backend
      tag: v1
      ports:
        - name: backend
          containerPort: 8088
      servicePort:
        - name: backend
          port: 8088
          targetPort: 8088
      labels:
        run: backend
        app: backend
      serviceType: ClusterIP
    #---
    frontend:
      name: react frontend websocket
      image: duong1200798/socket_app_react
      tag: v1
      ports:
        - name: frontend
          containerPort: 80
      servicePort:
        - name: frontend
          port: 80
          targetPort: 80
      labels:
        run: frontend
        app: frontend
      serviceType: ClusterIP
    #---
    database:
      name: mysql websocket
      image: duong1200798/socket_app_mysql
      tag: v1
      ports:
        - name: database
          containerPort: 3306
      servicePort:
        - name: database
          port: 3306
          targetPort: 3306
      labels:
        run: database
        app: database
      serviceType: ClusterIP
    #---
    logstash:
      name: logstash
      image: logstash
      tag: 7.16.3
      ports:
        - name: logstash
          containerPort: 5044
      servicePort:
        - name: logstash
          port: 5044
          targetPort: 5044
      labels:
        run: logstash
        app: logstash
      serviceType: ClusterIP
    #---
    elasticsearch:
      name: elasticsearch
      image: elasticsearch
      tag: 7.16.3
      ports:
        - name: client
          containerPort: 9200
        - name: nodes
          containerPort: 9300
      servicePort:
        - name: client
          port: 9200
          targetPort: 9200
        - name: nodes
          port: 9300
          targetPort: 9300
      labels:
        run: elasticsearch
        app: elasticsearch
      serviceType: ClusterIP
    #---
    kibana:
      name: kibana
      image: kibana
      tag: 7.16.3
      ports:
        - name: kibana-port
          containerPort: 5601
      servicePort:
        - name: kibana-port
          port: 5601
          targetPort: 5601
      labels:
        run: kibana
        app: kibana
      serviceType: ClusterIP

sideCarContainer:
  backend:
    - name: filebeat
      image: elastic/filebeat:7.16.3
      args:
        - -c
        - /etc/filebeat/conf.yaml
        - -e
      volumeMounts:
        - name: filebeat-config
          mountPath: /etc/filebeat
        - name: log
          mountPath: /var/log
  frontend:
    - name: filebeat
      image: elastic/filebeat:7.16.3
      args:
        - -c
        - /etc/filebeat/conf.yaml
        - -e
      volumeMounts:
        - name: filebeat-config
          mountPath: /etc/filebeat
        - name: log
          mountPath: /var/log
  database:
    - name: filebeat
      image: elastic/filebeat:7.16.3
      args:
        - -c
        - /etc/filebeat/conf.yaml
        - -e
      volumeMounts:
        - name: filebeat-config
          mountPath: /etc/filebeat
        - name: log
          mountPath: /var/log
  elasticsearch: []
  kibana: []
  logstash: []

# Additional ingress on the output Deployment definition.
ingress:
  backend:
    name: socket-ingress-api
    className: nginx
    rules:
      - http:
          paths:
            - path: /api(/|$)(.*)
              pathType: ImplementationSpecific
              backend:
                service:
                  name: backend
                  port:
                    number: 8088
    annotations:
      nginx.ingress.kubernetes.io/rewrite-target: /$2
      nginx.ingress.kubernetes.io/use-regex: "true"
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
  # ---
  frontend:
    name: socket-ingress
    className: nginx
    rules:
      - http:
          paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: frontend
                  port:
                    number: 80
    annotations:
      nginx.ingress.kubernetes.io/ssl-redirect: "false"
  # ---
  elasticsearch:
    name: elasticsearch-ingress
    className: nginx
    rules:
      - host: elasticsearch.duongdx.com
        http:
          paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: elasticsearch
                  port:
                    number: 9200
  # ---
  kibana:
    name: kibana-ingress
    className: nginx
    rules:
      - host: kibana.duongdx.com
        http:
          paths:
            - path: /
              pathType: Prefix
              backend:
                service:
                  name: kibana
                  port:
                    number: 5601
    annotations:
      nginx.ingress.kubernetes.io/ssl-redirect: "false"

# Additional config map on the output Deployment definition.
configMaps:
  backend:
    name: backend-configmap
    data:
      app-env: dev
      app-port: "8088"
      db-driver: mysql
      db-host: database
      db-port: "3306"
  #---
  frontend:
    name: front-configmap
    data:
      api-url: https://duongdx.com/api #need a endpoint, which client browser can access
      websocket-url: wss://duongdx.com/api/ws #need a endpoint, which client browser can access
  #---
  filebeat-config:
    name: filebeat-config
    data:
      conf.yaml: |
        filebeat.inputs:
        - type: log
          paths:
            - '/var/log/*.log'
          tags: ["my_app"]
        output:
          logstash:
            hosts: [ "logstash:5044" ]
  #---
  logstash:
    name: logstash
    data:
      access-log.conf: |
        input {
          beats {
            port => "5044"
          }
        }
        filter {
            grok {
                add_field => [ "received_at", "%{@timestamp}" ]
            }
        }
        output {
          if "my_open_source" in [tags] {
             elasticsearch {
               hosts => [ "elasticsearch-master:9200" ]
               index => "logstash_my_open_source_%{+YYYY.MM.dd}"
               }
             }
          else if "my_app" in [tags] {
             elasticsearch {
               hosts => [ "elasticsearch-master:9200" ]
               index => "logstash_my_app_%{+YYYY.MM.dd}"
               }
             }
          else {
             elasticsearch {
               hosts => [ "elasticsearch-master:9200" ]
               index => "logstash_default_%{+YYYY.MM.dd}"
               }
          }
        }
# Additional secret on the output Deployment definition.
secret:
  name: database-secret
  data:
    db-database: "c29ja2V0LWFwcA=="
    db-password: "ZHVvbmdkeDE="
    db-user: "ZHVvbmdkeA=="

# Additional secret on the output Deployment definition.
persistenVolumeClaim:
  name: database-pvc
  storageClassName: socket-app-storage-class
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 100Mi


# Additional replication on the output Deployment definition.
replication:
    backend: 2
    frontend: 2
    database: 1
    logstash: 1
    elasticsearch: 1
    kibana: 1

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# environment variable

environmentVarialbes:
  backend:
    - name: APP_PORT
      valueFrom:
        configMapKeyRef:
          name: backend-configmap
          key: app-port
    - name: APP_ENV
      valueFrom:
        configMapKeyRef:
          key: app-env
          name: backend-configmap
    - name: DB_DRIVER
      valueFrom:
        configMapKeyRef:
          key: db-driver
          name: backend-configmap
    - name: DB_HOST
      valueFrom:
        configMapKeyRef:
          key: db-host
          name: backend-configmap
    - name: DB_PORT
      valueFrom:
        configMapKeyRef:
          key: db-port
          name: backend-configmap
    - name: DB_USER
      valueFrom:
        secretKeyRef:
          key: db-user
          name: database-secret
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          key: db-password
          name: database-secret
    - name: DB_DATABASE
      valueFrom:
        secretKeyRef:
          key: db-database
          name: database-secret
  #---
  frontend:
    - name: REACT_APP_WS_URL
      valueFrom:
        configMapKeyRef:
          name: front-configmap
          key: websocket-url
    - name: REACT_APP_API_URL
      valueFrom:
        configMapKeyRef:
          name: front-configmap
          key: api-url
  #---
  database:
    - name: MYSQL_USER
      valueFrom:
        secretKeyRef:
          name: database-secret
          key: db-user
    - name: MYSQL_PASSWORD
      valueFrom:
        secretKeyRef:
          name: database-secret
          key: db-password
    - name: MYSQL_ROOT_PASSWORD
      valueFrom:
        secretKeyRef:
          name: database-secret
          key: db-password
    - name: MYSQL_DATABASE
      valueFrom:
        secretKeyRef:
          name: database-secret
          key: db-database
  #---
  elasticsearch:
    - name: JAVA_TOOL_OPTIONS
      value: -Xmx256m -Xms256m
    - name: discovery.type
      value: single-node

# Additional volumes on the output Deployment definition.
volumes:
  backend:
    - name: log
      emptyDir: { }
    - name: filebeat-config
      configMap:
        name: filebeat-config
  frontend:
    - name: log
      emptyDir: { }
    - name: filebeat-config
      configMap:
        name: filebeat-config
  database:
    - name: log
      emptyDir: { }
    - name: filebeat-config
      configMap:
        name: filebeat-config
    - name: persistent-volume
      persistentVolumeClaim:
        claimName: database-pvc
  logstash:
    - name: logstash-config
      configMap:
        name: logstash

# Additional volumeMounts on the output Deployment definition.
volumeMounts:
  backend:
    - name: log
      mountPath: /var/log
  frontend:
    - name: log
      mountPath: /var/log/nginx
  database:
    - name: log
      mountPath: /var/log/mysql
    - name: persistent-volume
      mountPath: "/var/lib/mysql"
  logstash:
    - name: logstash-config
      mountPath: /usr/share/logstash/pipeline


# Addition initContainers on the output Deployment definition
initContainers:
  backend:
    - name: service-checker
      image: busybox
      command: [ 'sh', '-c', 'until nslookup database.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mysql up; sleep 2; done;' ]
  # ---
  frontend:
    - name: service-checker
      image: busybox
      command: [ 'sh', '-c', 'until nslookup backend.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for backend up; sleep 2; done;' ]
  # ---
  database: []

# Addition initContainers on the output Deployment definition
resources:
  # backend resources
  backend:
    requests:
      memory: "128Mi"
      cpu: "64m"
    limits:
      memory: "250Mi"
      cpu: "250m"
  # frontend resources
  frontend: {}
  # database resources
  database: {}
  # elasticsearch resources
  elasticsearch:
    requests:
      memory: 500Mi
      cpu: 0.5
    limits:
      memory: 500Mi
      cpu: 0.5

nodeSelector: {}

tolerations: []

affinity: {}

# Dependencies configuration: ingress-nginx
ingress-nginx:
  enabled: true
  controller:
    scope:
      enabled: true
      #namespace: "socket-namespace" # let's check it--------------------------------------------
      # get namespace's labels: kubectl get namespace "namespace-name" --show-labels
      namespaceSelector: "app=nginx-ingress" # must run: kubectl label namespace "namespace-name" app=nginx-ingress
    nodeSelector:
      kubernetes.io/hostname: node01 # check your node
    ingressClass: nginx
    service:
      type: NodePort
      nodePorts:
        http: 30098
        https: 30443

# Dependencies configuration: nfs server for mysql
socket-app-nfs:
  enabled: true
  nfs:
    server: 192.168.56.198
    path: /mnt/mysql
    # Reclaim policy for the main nfs volume
    reclaimPolicy: Retain
  storageClass:
    name: socket-app-storage-class
    testing: ReadWriteMany
    archiveOnDelete: true
    onDelete: retain
    reclaimPolicy: Retain

# Dependencies configuration: metrics-server
# Addition horizontal pod scale:
horizontalPortCscale:
  backend:
    maxReplicas: 5
    minReplicas: 2
    scaleTargetRef:
      apiVersion: apps/v1
      kind: Deployment
      name: backend
    targetCPUUtilizationPercentage: 60
  frontend: {}
  database: {}

metricServerEnable:
  backend: true
  frontend: false
  database: false

metrics-server:
  enabled: true
  defaultArgs:
    - --cert-dir=/tmp
    - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
    - --kubelet-use-node-status-port
    - --metric-resolution=15s
    - --kubelet-insecure-tls # must add for running

